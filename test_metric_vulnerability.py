import pytest
from monthly_analysis import SpotifyAnalyzer

def test_fle_outlier_vulnerability():
    analyzer = SpotifyAnalyzer()
    
    # Track "A" has two records:
    # 1. A normal listen (180s = 180000ms)
    # 2. A glitch/extended version (600s = 600000ms)
    
    records = [
        {
            "ts": "2023-01-01T10:00:00Z",
            "master_metadata_track_name": "Song A",
            "master_metadata_album_artist_name": "Artist X",
            "ms_played": 180000
        },
        {
            "ts": "2023-01-01T10:10:00Z",
            "master_metadata_track_name": "Song A",
            "master_metadata_album_artist_name": "Artist X",
            "ms_played": 600000
        }
    ]
    
    analyzer.collect_records(records)
    analyzer.finalize_durations()
    analyzer.process_data()
    report = analyzer.get_report(top_n=1)
    
    song_info = report["alltime"]["songs"][0]
    
    # Current logic: max_ms = 600000. 
    # Total ms = 180000 + 600000 = 780000.
    # FLE = 780000 / 600000 = 1.3 FLE.
    
    # Expected robust logic:
    # Most frequent (or representative) duration should be ~180000 or ~max(but filtered).
    # If the "true" length is 180s, then 600s is likely a glitch or something else.
    # 1.3 FLE for two listens (one being 3x the length) isn't necessarily wrong if both are "full",
    # but let's look at it from the "Deflation" angle:
    
    # Case 2: One 10-hour glitch record (36,000,000ms) and ten 3-minute listens (1,800,000ms total).
    analyzer_glitch = SpotifyAnalyzer()
    glitch_records = [
        {
            "ts": "2023-01-01T00:00:00Z",
            "master_metadata_track_name": "Song B",
            "master_metadata_album_artist_name": "Artist Y",
            "ms_played": 36000000 # 10 hours
        }
    ] + [
        {
            "ts": f"2023-01-02T{i:02d}:00:00Z",
            "master_metadata_track_name": "Song B",
            "master_metadata_album_artist_name": "Artist Y",
            "ms_played": 180000 # 3 mins
        } for i in range(10)
    ]
    
    analyzer_glitch.collect_records(glitch_records)
    analyzer_glitch.finalize_durations()
    analyzer_glitch.process_data()
    
    report_glitch = analyzer_glitch.get_report(top_n=100)
    song_b = [s for s in report_glitch["alltime"]["songs"] if s["name"] == "Song B"][0]
    
    # Expected:
    # Ref duration = 180,000
    # Record 1 (glitch): min(36M/180K, 2.0) = 2.0 FLE
    # Records 2-11: 1.0 FLE each
    # Total = 12.0 FLE
    
    print(f"Song B FLE (New): {song_b['score']}")
    
    assert song_b['score'] == 12.0, f"Expected Song B to have exactly 12.0 FLE, but got {song_b['score']}"

if __name__ == "__main__":
    test_fle_outlier_vulnerability()
